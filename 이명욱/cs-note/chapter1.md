# chapter1 디자인 패턴과 프로그래밍 패러다임

작성자 : 이명욱

## 디자인 패턴

### 싱글톤 패턴
하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴, 데이터베이스 연결 모듈에 많이 사용
- 장점: 인스턴스를 생성할 때 드는 비용이 줄어듬
- 단점: 의존성이 높아짐, TDD 어려움

```js
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this
    }
    return Singleton.instance
  }
  getInstance() {
    return this
  }
}

const a = new Singleton();
const b = new Singleton();
console.log(a === b) // true
```

> 의존성 주입(DI)를 통해 모듈 간의 결합(싱글톤 단점)을 느슨하게 만들 수 있음!
> - 장점: 테스팅, 마이그레이션 용이
> - 단점: 클래스 수 증가로 복잡성 증가 -> 런타임 패널티 

### 팩토리 패턴
1. 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴
2. 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대, 하위 클래스에서 객체 생성에 관한 구체적 내용 결정
- 장점: 느슨한 결합, 유연성, 유지 보수성 증가

### 전략 패턴
객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴
- 활용: passport 라이브러리(localStrategy, OAuth), 결제 서비스(NaverPay, KakaoPay 등)

### 옵저버 패턴
주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버들에게 변화를 알려주는 패턴
- 활용: 이벤트 기반 시스템, MVC패턴, 구 twitter

- 프록시 객체를 통해 구현 가능
> 프록시 객체: 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체

### 프록시 패턴
프록시 패턴은 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링하거나 수정하는 등의 역할을 하는 계층
- 활용: 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅

### 프록시 서버
서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램
- 예시: nginx(보안 강화), CloudFlare(DDOS 공격 방어, HTTPS 구축), CORS 에러 해결

> CDN(Content Delivery Network): 각 사용자가 인터넷에 접속하는 곳과 가까운 곳에서 콘텐츠를 캐싱 또는 배포하는 서버 네트워크(웹 서버로부터 콘텐츠를 다운로드하는 시간 줄일 수 있음)

### 이터레이터 패턴
이터레이터(iterator)를 사용하여 컬렉션(collection)의 요소들에 접근하는 패턴
- 예시: for 문

### 노출모듈 패턴
즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴
- 활용: CJS(CommonJS) 모듈 방식

> 즉시 실행 함수: 함수를 정의하자마자 바로 호출하는 함수. 초기화 코드, 라이브러리 내 전역 변수의 충돌 방지 등에 사용

### MVC 패턴
모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 패턴

- 모델: 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등
- 뷰: inputbox, checkbox, textarea 등 사용자 인터페이스 요소(사용자가 볼 수 있는 화면)
- 컨트롤러: 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직 담당
- 장점: 재사용성, 확장성
- 단점: 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해짐

### MVP 패턴
C(컨트롤러) -> P(프레젠터)로 교체, 뷰와 프레젠터는 일대일 관계로 MVC 패턴 보다 더 강한 결합

### MVVM 패턴
C(컨트롤러) -> VM(뷰 모델), 뷰모델은 뷰를 더 추상화한 계층, MVC 패턴과 다르게 커맨트와 양방향 데이터 바인딩(UI 재사용, 단위 테스팅 용이)을 가짐
- 예시: Vue.js(반응형, watch, computed)

## 프로그래밍 패러다임
```markdown
프로그래밍 패러다임
├── 선언형
│   └── 함수형
└── 명령형
    ├── 객체지향형 
    └── 절차지향형 
```

### 선언형과 함수형 프로그래밍
- 선언형 프로그래밍: '무엇을' 풀어내는가에 집중하는 패러다임. '프로그램은 함수로 이루어진 것이다'
- 함수형 프로그래밍: 선언형 패러다임의 일종, **작은 '순수 함수'들을 블록처럼 쌓아 로직을 구현하고 '고차함수'를 통해 재사용성을 높인 프로그래밍 패러다임**
> 자바스크립트는 단순하고 유연한 언어, js 함수가 일급 객체이기 때문에 객체 지향 프로그래밍보다는 함수형 프로그래밍 방식이 선호

#### 순수 함수
출력이 입력에만 의존하는 것

#### 고차 함수
함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것

고차 함수를 쓰기 위해서는 해당 언어가 일급 객체라는 특징을 가져야 함

> 일급객체란?
> 1. 변수나 메서드에 함수를 할당
> 2. 함수 안에 함수를 매개변수로 담을 수 있음
> 3. 함수가 함수를 반환할 수 있음

### 객체지향 프로그래밍
객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식, 설계에 많은 시간이 소요

```js
// 객체지향 프로그래밍
const ret = [1, 2, 3, 4, 5, 11, 12]
class List {
    constructor(list) {
        this.list = list
        this.mx = list.reduce((max, num) => num > max ? num : max, 0)
    }
    getMax() {
        return this.mx
    }
}
const a = new List(ret)
console.log(a.getMax()) // 12
```

```js
// 함수형 프로그래밍
const ret = [1, 2, 3, 4, 5, 11, 12]

const getMax = (list) => {
    return list.reduce((max, num) => num > max ? num : max, 0)
    // Math.max(...list)
}

console.log(getMax(ret)) // 12
```

- 특징
  - 추상화: 복잡한 시스템으로부터 핵심적인 개념 또는 기능 간추려내는 것
  - 캡슐화: 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉
  - 상속성: 상위 클래스의 특성을 하위 클래스가 재사용, 추가, 확장하는 것
  - 다형성: 하나의 메서드나 클래스가 다양한 방법으로 동작(ex. 오버로딩, 오버라이딩)

- 설계 원칙(SOLID)
  - 단일 책임 원칙(SRP): 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙
  - 개방-폐쇄 원칙(OCP): 유지 보수 사항이 생긴다면 코드를 쉽게 확장, 수정할 때는 닫혀 있어야 하는 원칙(확장 o, 수정 x)
  - 리스코프 치환 원칙(LSP): 프로그램의 객체는 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함(부모 클래스를 자식 클래스로 대체 가능!)
  - 인터페이스 분리 원칙(ISP): 구체적인 여러개 개의 인터페이스를 만들어야 하는 원칙
  - 의존 역전 원칙(DIP): 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙(상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립(영향 x))

### 절차형 프로그래밍
로직이 수행되어야 할 연속적인 계산 과정으로 이루어짐
- 예시: 포트란을 이용한 대기 과학 연산, 머신 러닝의 배치 작업
- 단점: 모듈화 어렵고 유지 보수성이 떨어짐

```js
const ret = [1, 2, 3, 4, 5, 11, 12]
let a = 0
for(let i = 0; i < ret.length; i++){
    a = Math.max(ret[i], a)
} 
console.log(a) // 12 
```

### 패러다임의 혼합
'어떠한 패러다임이 가장 좋을까요'에 대한 정답은 없음!

[예제 소스](https://github.com/wnghdcjfe/csnote)